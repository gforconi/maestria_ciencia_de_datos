---
title: "TP Final - Introducción al Data Mining"
author: "Geronimo Forconi"
date: '2022-09-02'
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: hide
  pdf_document:
    toc: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Importo librerias
library(knitr) #Tablas lindas
library(kableExtra) #Tablas lindas
#library(readr) #Para lectura de csv
library(ggplot2) #Graficos
library(plotly) #Graficos
library(hrbrthemes) #Temas para graficos
library(patchwork) #Para mostrar graficos juntos
library(dplyr) #Para gather(), #Para quantile()
library(viridis) #Para diagraba boxplot
#library(data.table) #Para transpose
#library(DescTools) #Para intervalo de confianza
#library(EnvStats) #Para intervalo de confianza -> varTest
#library(nortest) #Para ad.test
#library(scales) #Para comma_format
#library(car) #Para leveneTest
library(psych) #Para grafico de correlación
library(DT) #Para tablas grandes
library(factoextra) # Para fviz_nbclust
library(corrplot) #Para corrplot
library(ggfortify) #Para autoplot
# Agrupamiento no jerarquico
library(factoextra) # Para fviz_nbclust
library(cowplot) #Para plot_grid
#prediccion
library(caret) #Para createDataPartition
library(Metrics) #Para auc
library(ROCR) #Para curva ROC / prediction
library(rpart.plot) #Para rpart.plot


#Configuracion inicial para las tablas
Form.Basic <- c("striped", "hover", "condensed", "responsive")

#Cargo los datos
df_bcra_individuals <- readRDS(file = "df_bcra_individuals.rds")
```

------------------------------------------------------------------------

<p class="text-center">MAESTRÍA EN CIENCIA DE DATOS</p>

<p class="text-center">UNIVERSIDAD AUSTRAL</p>

<p class="text-center">ASIGNATURA: Introducción al Data Mining</p>

<p class="text-center">Forconi Gerónimo</p>

<p class="text-center">FEBRERO DE 2023</p>

------------------------------------------------------------------------

# Caso de estudio

## Introducción

*ESTUDIO DE LAS DEUDAS REGISTRADAS DEL SISTEMA FINANCIERO ARGENTINO*

El Banco Central de la República Argentina (BCRA) publica mensualmente un informe consolidado de deudas actuales e históricas (24 meses), denominado 'Central de Deudores del Sistema Financiero' elaborado en función de los datos recibidos de distintos tipos de entidades financieras (entidades financieras, empresas no financieras emisoras de tarjetas, fideicomisos financieros, otros proveedores no financieros de crédito, etc.), las cuales deben obligatoriamente remitir mensualmente al BCRA, detallando la totalidad de las financiaciones con la correspondiente situación de cada deudor.

Cada deuda informada al BCRA es acompañada de su situación que es una aproximación a la cantidad de días de atraso en el cumplimiento de pago:

Situación 1 | Situación normal: atraso en el pago que no supere los 31 días. 

Situación 2 | Riesgo bajo: atraso en el pago de más de 31 días y hasta 90 días. 

Situación 3 | Riesgo miedo: atraso en el pago de más de 90 días y hasta 180 días. 

Situación 4 | Riesgo alto: atraso en el pago de más de 180 días a un año. 

Situación 5 | Irrecuperable: atraso superior a un año.

Situación 6 | Irrecuperable por disposición técnica: deuda con una ex entidad.

Se cuenta con una muestra aleatoria de 18.021 cuits de personas físicas que tenían al menos una de deuda en el sistema financiero en Junio de 2019, que se encontraban en situación crediticia 1 o 2 (es decir, que no tuvieran atrasos mayores a 90 días) y cuyo monto total adeudado en ese momento no superaba los 100.000 pesos argentinos.

Para los cuits de la muestra aleatoria se registraron y resumieron las deudas en todas las entidades en Junio de 2019 y también 6 meses hacia atrás. También se registraron las deudas de esos cuits entre Julio 2019 y Junio 2020 para poder evaluar su evolución.

En el conjunto de datos ‘df_bcra_individuals.rds’ se encuentra la información registrada, con las siguientes 30 variables:


```{r echo=FALSE, message=FALSE}
variables <- data.frame(
  id = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30),
  variable=c( "id_individuo"
              , "tipo_persona"
              , "n_deudas_actual"
              , "proxy_edad_actual"
              , "deuda_total_actual"
              , "deuda_con_garantia_actual"
              , "situacion_mes_actual"
              , "prop_con_garantia_actual"
              , "tiene_garantia_actual"
              , "mora_30_dias_mes_actual"
              , "n_meses_seg_bcra"
              , "media_deuda_total"
              , "media_deuda_situacion_1"
              , "media_deuda_situacion_2"
              , "media_deuda_con_garantia"
              , "media_deuda_sin_garantia"
              , "media_deuda_en_default"
              , "max_situacion_mes"
              , "max_sit_mes_con_garantia"
              , "max_sit_mes_sin_garantia"
              , "media_prop_situacion_1"
              , "media_prop_situacion_2"
              , "media_prop_default"
              , "media_prop_con_garantia"
              , "prop_tuvo_garantia"
              , "prop_mora_30_dias_seg"
              , "prop_default_seg"
              , "peor_situacion_respuesta"
              , "default"
              , "mora_mayor_30_dias"),
  descripcion=c( "identificación del individuo (anonimizada)."
               , "primeros dos dígitos del cuit (20: hombres; 27: mujeres)."
               , "cantidad de entidades en las que el cuit tenía al menos una deuda en Jun-2019."
               , "tres primeros números del dni."
               , "monto total de deuda en Jun-2019 (expresada en miles de pesos)."
               , "monto total de deuda garantizada en Jun-2019 (expresada en miles de pesos)."
               , "situación crediticia más grave en todas las deudas del cuit en Jun-2019."
               , "proporción de la deuda garantizada en Jun-2019."
               , "variable indicadora (0: no, 1: si) de si el cuit tenía al menos una deuda garantizada en Jun-2019."
               , "variable indicadora (0: no, 1: si) de si el cuit estaba en situación 2 en Jun-2019."
               , "cantidad de meses en los que el cuit tenía al menos una deuda informada en el sistema financiero, entre Dic-2018 y Jun-2019."
               , "promedio de la deuda total entre Dic-2018 y Jun-2019."
               , "promedio de la deuda en situación 1 entre Dic-2018 y Jun-2019."
               , "promedio de la deuda en situación 2 entre Dic-2018 y Jun-2019."
               , "promedio de la deuda garantizada entre Dic-2018 y Jun-2019."
               , "promedio de la deuda no garantizada entre Dic-2018 y Jun-2019."
               , "promedio de la deuda en defaut (situación 3 o peor) entre Dic-2018 y Jun-2019."
               , "maxima situación entre Dic-2018 y Jun-2019"
               , "maxima situación en las deudas garantizadas entre Dic-2018 y Jun-2019."
               , "maxima situación en las deudas no garantizadas entre Dic-2018 y Jun-2019."
               , "promedio de la proporción de deuda en situación 1 entre Dic-2018 y Jun-2019."
               , "promedio de la proporción de deuda en situación 2 entre Dic-2018 y Jun-2019."
               , "promedio de la proporción de deuda en default entre Dic-2018 y Jun-2019."
               , "promedio de la proporción de deuda garantizada entre Dic-2018 y Jun-2019."
               , "proporción de meses en los cuales el cuit tuvo deuda garantizada, entre Dic-2018 y Jun-2019."
               , "proporción de meses en los cuales el cuit estuvo en situación 2, entre Dic-2018 y Jun-2019."
               , "proporción de meses en los cuales el cuit estuvo en default, entre Dic-2018 y Jun-2019."
               , "situación crediticia más grave en todas las deudas del cuit entre Jul-2019 y Jun- 2020."
               , "situación crediticia más grave mayor o igual 3 en todas las deudas del cuit entre Jul-2019 y Jun-2020."
               , "situación crediticia más grave igual 2 en todas las deudas del cuit entre Jul-2019 y Jun-2020."
               )
)
kable(variables, caption="Variables:") %>% 
  kable_styling(bootstrap_options=Form.Basic)
```

## Consignas

Consignas:

a. Describa la distribución univariada de las variables presente en el conjunto de datos. ¿Se evidencian outliers en alguna de ellas?

b. Calcule e interprete la matriz de correlaciones de variables disponibles a Jun-2019 (las posibles predictores de default en el período Jul-2019 a Jun-2020).

c. Realice un análisis de componentes principales sobre las mismas variables. ¿Qué porcentaje de la variabilidad total logran explicar las dos primeras componentes? ¿Es posible realizar una interpretación sobre los componentes? ¿Cuál? ¿Logran esas componentes diferenciar a los cuits según el tipo de persona?

d. ¿Existen distintos subgrupos de cuits en los datos? ¿Cuántos logra identificar? ¿Qué características tienen? Explique la metodología utilizada.

e. Construya un modelo predictivo para a variable respuesta ‘default’ utilizando sólo las variables disponibles a Jun-2019. ¿Qué capacidad predictiva tiene ese modelo?

f. ¿Utilizaría el modelo construido para evaluar futuros solicitantes de crédito? Justifique su respuesta.




# Solución

## a. Descripción de las variables

> Describa la distribución univariada de las variables presente en el conjunto de datos. ¿Se evidencian outliers en alguna de ellas?

### id_individuo

> Identificación del individuo (anonimizada).

Esta variables es un Identificador, no merece ningún tipo de análisis

Tipo de variable: ***Identificador***

### tipo_persona

> Primeros dos dígitos del cuit (20: hombres; 27: mujeres).

En el enunciado se menciona que existen dos posibles valores 20 para hombres y 27 para mujeres, pero en realidad existe también los valores 23 y 24 los cuales se utilizan para ambos sexos en caso de que ya exista un CUIT idéntico. 

Sin tener en cuenta los valores 23 y 24 vemos que los otros dos valores se distribuyen de forma uniforme. Es decir no hay una prevalencia de un sexo sobre el otro.

```{r}

g <- df_bcra_individuals %>% 
  group_by(tipo_persona) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100,
         tipo_persona_desc = case_when(tipo_persona == 27 ~ "Mujeres 27",
                                       tipo_persona == 20 ~ "Hombres 20",
                                       tipo_persona == 23 ~ "Sin Definir 23",
                                       tipo_persona == 24 ~ "Sin Definir 24",
                                       TRUE ~ "Sin Clasificar")
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=reorder(tipo_persona_desc, -PorcTotal)
             , text = paste("Tipo Persona: ", tipo_persona_desc
                            , "\nCodigo: ", tipo_persona
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
             )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Tipo Persona") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Tipo de Persona")
  


ggplotly(g, tooltip="text")

```

Evidencia de outliers: ***Si bien existe dos tipos de datos que no son mencionados en el enunciado, no hay indicios de que sean outliers. Entiendo que se puede seguir trabajando con el dataset tal cual esta y mas adelante evaluar si estos tipos de datos generan "ruido" en algún análisis particular.*** 

Tipo de variable: ***Cualitativa - Discreta***

### n_deudas_actual

> Cantidad de entidades en las que el cuit tenía al menos una deuda en Jun-2019.

El 63% de las personas tiene deuda con una entidad y luego va bajando el porcentaje a medida que se va agrandando la cantidad de entidades hasta llegar a 7. 


```{r warning=FALSE}


g<- df_bcra_individuals %>% 
  group_by(n_deudas_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
           PorcTotal = (Cantidad / sum(Cantidad))*100
        )  %>% 
  ggplot(aes(y=PorcTotal
             , x=n_deudas_actual
             , text = paste("Cantidad Deudas Actual: ", n_deudas_actual
                            , "\nFrecuencia Relativa: ", PorcTotal_lbl
                            , "\nFrecuencia: ", Cantidad
                      ) 
             )
         ) + 
    geom_bar(position="stack", stat="identity", fill='#69b3a2') +
    geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
    theme_ipsum() +
    theme(plot.title = element_text(size=11)) +
    xlab("Cantidad Deudas Actual") +
    ylab("Frecuencia Relativa") +
    ggtitle("Frecuencia Relativa - Cantidad Deudas Actual")

ggplotly(g, tooltip="text")
```

Si comparamos la cantidad de entidades en las que el cuit tenía al menos una deuda en Jun-2019 con la situación en Jun-2019 observamos que el 98% de las personas que tiene una deuda están en situación 1 y el 2% en situación 2.
Se observa que la proporción de cuit en situación 2 es mucho menor que la situación 1 para cada cantidad de entidades.

```{r warning=FALSE, message=FALSE}

g<- df_bcra_individuals %>% 
  group_by(n_deudas_actual, situacion_mes_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  ggplot(aes(y=PorcTotal
             , x=n_deudas_actual
             , fill = situacion_mes_actual
             , text = paste("Cantidad Deudas Actual: ", n_deudas_actual
                            ,"\nsituación Mes Actual: ", situacion_mes_actual
                            , "\nFrecuencia Relativa: ", PorcTotal_lbl
                            , "\nFrecuencia: ", Cantidad
             ) 
  )
  ) + 
  geom_bar(position="stack", stat="identity") +
  scale_fill_discrete("Situación") +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Cantidad Deudas Actual") +
  ylab("Porcentaje") +
  ggtitle("Cantidad Deudas Actual por Situación actual") +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5)

ggplotly(g, tooltip="text")

```

```{r warning=FALSE, message=FALSE}
data <- df_bcra_individuals %>% 
  group_by(n_deudas_actual, situacion_mes_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  )

data <- data[,-5]
colnames(data) <- c("Cant. Deudas Actual", "situación Actual", "Frecuencia", "Frecuencia Relativa")
kable(data, caption="Tabla de Frecuencias:", align=rep('c', 2)) %>% 
  kable_styling(bootstrap_options=Form.Basic)

```

Evidencia de outliers: ***Se observa una muestra con valor 10, parecería ser un outliers teniendo en cuenta que es una sola ocurrencia, representa un 0.006% del total de muestras. Considerando que no hay muestras con valores 8 y 9, esto evidencia aún mas la posibilidad de que sea un valor atípico.*** 

Tipo de variable: ***Cuantitativa - Discreta***

### proxy_edad_actual 

> Tres primeros números del dni.

Se observan números de dos cifras, suponemos que el valor faltante es cero y la intención es poder representar los millones en los primeros dos dígitos y en el tercero los cientos de miles. Por ejemplo, el valor 81, sería 8 millones 100 mil. El valor 332 sería 33 millones 200 mil. Por otro lado observo que en los 19 millones hay una situación particular, hay observaciones con 190 y luego salta al 205 esto se debe a que los 19 millones no fueron asignados, fueron reservados para situaciones particulares como ser alguna personas que no posee DNI desde su nacimiento, u alguna otra situación inusual.

También existe otra franja entre los 14 millones y los 16 millones donde no se observan valores.
Y pasa algo parecido entre los 8,7 millones y 9,9 millones.

Existe un valor en cero, esto es raro, no se si es un outliers ya que hay varios valores por debajo del millón.


```{r warning=FALSE}
g <- df_bcra_individuals %>% 
  group_by(proxy_edad_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  ggplot( aes(y= Cantidad
              , x=proxy_edad_actual
              , text = paste("Primeros tres dígitos: ", proxy_edad_actual
              , "\nFrecuencia Relativa: ", PorcTotal_lbl
              , "\nFrecuencia: ", Cantidad
                             )
              )
          ) +
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  theme_ipsum() +
  xlab("Primeros tres números del DNI") +
  ylab("Cantidad") +
  ggtitle("Primeros tres números del DNI") +
  theme(
    plot.title = element_text(size=11)
  )

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***Existen dos observaciones con valores 604 y 629 los cuales son posibles outliers, determinaremos mas adelante si los quitamos o no.***

Tipo de variable: ***Cuantitativa - Discreta***

### deuda_total_actual

> Monto total de deuda en Jun-2019 (expresada en miles de pesos).

Esta variable tiene un filtro en el data set original, es por eso que se visualiza en 100 mil un corte recto. Tenemos las deudas menores a 100 mil. 

```{r}
df_summary <- summary(df_bcra_individuals$deuda_total_actual)
df_t <- data.table::transpose(data.frame(unclass(df_summary)))
colnames(df_t) <- rownames(data.frame(unclass(df_summary)))
df_t <- cbind(df_t,"Desviación Standar"=sd(df_bcra_individuals$deuda_total_actual))
kable(df_t, caption="Resumen de Indicadores:") %>% 
  kable_styling(bootstrap_options=Form.Basic)
```

Como valor mínimo tenemos mil y como valor máximo 99. No se observan valores nulos. Luego se observa que la media es 29.13795 y la mediana de 21, esto nos indica que tenemos una distribución con cola a la derecha. En el gráfico que esta debajo se observa mejor.
En cuanto a la desviacion estandar (25.17) se observa un valor elevado.

```{r warning=FALSE}
g<- df_bcra_individuals %>%
  ggplot( aes(x=deuda_total_actual)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Monto Deuda") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )

g2 <- ggplot( data = df_bcra_individuals, aes(x=factor(0), y=deuda_total_actual)) +
  geom_boxplot(fill='#69b3a2') +
  scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
  theme_ipsum() +
  ggtitle("Boxplot") + 
  ylab("Monto Total Deuda") +
  xlab("") + 
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  ) 

#Imprimo los graficos juntos
g + g2
```


Evidencia de outliers: ***Si bien en el boxplot se marcan algunos puntos cercanos al 100, no son valores alejados al resto. Podemos decir que no se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### deuda_con_garantia_actual (revisar)

> Monto total de deuda garantizada en Jun-2019 (expresada en miles de pesos).

Para analizar esta variable me voy a centrar únicamente en los cuit que tienen garantia actual. Ya que si analizo todo se distorsiona la gráfica y los análisis son mas complicados de interpretar.

```{r}
data <- df_bcra_individuals %>% filter(tiene_garantia_actual==1)
df_summary <-  summary(data$deuda_con_garantia_actual)
df_t <- data.table::transpose(data.frame(unclass(df_summary)))
colnames(df_t) <- rownames(data.frame(unclass(df_summary)))
df_t <- cbind(df_t,"Desviación Standar"=sd(df_bcra_individuals$deuda_con_garantia_actual))
kable(df_t, caption="Resumen de Indicadores:") %>% 
  kable_styling(bootstrap_options=Form.Basic)
```

Se observa que la media de la deuda garantizada es de 39.05 el rango de deuda es de mil (1) hasta los cien mill (limite del dataset). La mediana es 36, la distribución es asimétrica con una leve cola a la derecha. 
El primer cuartil (Q1) es 11 millones, es decir, 25% de las montos total de deuda garantizada es de 11 millones o menos. El tercer cuartil (Q3) es 58 millones, es decir, 75% de las montos total de deuda garantizada es de 11 millones o menos.

(revisar)(regla de 80/20 preguntar para agregar)

```{r}
g<- df_bcra_individuals %>%
  filter(tiene_garantia_actual==1) %>%
  ggplot( aes(x=deuda_con_garantia_actual)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Deuda Con Garantia Actual") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
  
  
g2 <- df_bcra_individuals %>% 
      filter(tiene_garantia_actual==1) %>%
      ggplot(aes(x=factor(0), y=deuda_con_garantia_actual)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Deuda Con Garantia Actual") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### situacion_mes_actual

> Situación crediticia más grave en todas las deudas del cuit en Jun-2019.

De los 18021 cuit existentes en el dataset 1320 (96%) están en Situación 1 en Junio de 2019. Mientras que el 4% (701 cuits) están en Situación 2.

```{r}
g <- df_bcra_individuals %>% 
  group_by(situacion_mes_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=reorder(situacion_mes_actual, -PorcTotal)
             , text = paste("Situación Mes Actual: ", situacion_mes_actual
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Situación Mes Actual") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Situación Mes Actual")


ggplotly(g, tooltip="text")

```

Evidencia de outliers: ***No tiene outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### prop_con_garantia_actual

> Proporción de la deuda garantizada en Jun-2019.

Al igual que la variable deuda_con_garantia_actual esta variable la analizare únicamente para los cuit que tienen deuda. Es decir, voy a tener por persona, el porcentaje que tienen de deuda con garantia. 

```{r}
data <- df_bcra_individuals %>% filter(tiene_garantia_actual==1)
df_summary <-  summary(data$prop_con_garantia_actual)
df_t <- data.table::transpose(data.frame(unclass(df_summary)))
colnames(df_t) <- rownames(data.frame(unclass(df_summary)))
df_t <- cbind(df_t,"Desviación Standar"=sd(df_bcra_individuals$prop_con_garantia_actual))
kable(df_t, caption="Resumen de Indicadores:") %>% 
  kable_styling(bootstrap_options=Form.Basic)
```

Se observa que la media de la proporción de la deuda garantizada actual es de 0.7666 el rango de la proporción va de 0.0405 a uno. Es decir, la proporción de deuda congarantia mas  chica es un 4% y la mayor un 100% (tiene toda la deuda con garantia). La mediana es 0.9052, la distribución es asimétrica con cola a la izquierda. 
El primer cuartil (Q1) es 0.6049107 porciento, es decir, 25% de las deudas tienen una proporción del 60% con garantia o menos. El tercer cuartil (Q3) es 100 porciento, es decir, 75% de deudas tienen una proporción del 100% con garantia o menos.

```{r}
g<- df_bcra_individuals %>%
  filter(tiene_garantia_actual==1) %>%
  ggplot( aes(x=prop_con_garantia_actual)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Proporción de Deuda Con Garantia Actual") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      filter(tiene_garantia_actual==1) %>%
      ggplot(aes(x=factor(0), y=deuda_con_garantia_actual)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Proporción de Deuda Con Garantia Actual") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2

```

La mayoria de la deuda con garantia tiene un porcentaje elevado de deuda garantizada, estamos hablando que la media tiene un 76% de la deuda garantizada con un desvio del 11%. Mas de la mitad de la deuda tiene garantia.

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### tiene_garantia_actual

> Variable indicadora (0: no, 1: si) de si el cuit tenía al menos una deuda garantizada en Jun-2019.

De los 18021 cuit existentes en el dataset 17675 (98%) no poseen garantia actual, mientras que el 2% (346 cuits) si poseen garantia actual.

```{r}
g <- df_bcra_individuals %>% 
  group_by(tiene_garantia_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=reorder(tiene_garantia_actual, -PorcTotal)
             , text = paste("Tiene Garantia Actual: ", tiene_garantia_actual
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Tiene Garantia Actual") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Tiene Garantia Actual")


ggplotly(g, tooltip="text")

```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### mora_30_dias_mes_actual

> Variable indicadora (0: no, 1: si) de si el cuit estaba en situación 2 en Jun-2019.

De los 18021 CUIT existentes en el dataset 17320 (96%) no estaban en situación 2 en Jun-2019, mientras que el 4% (701 CUITs) estaban en situación 2.

```{r}
g <- df_bcra_individuals %>% 
  group_by(mora_30_dias_mes_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=reorder(mora_30_dias_mes_actual, -PorcTotal)
             , text = paste("Mora 30 Dias Mes Actual: ", mora_30_dias_mes_actual
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Mora 30 dias mes actual") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Mora 30 dias mes actual")


ggplotly(g, tooltip="text")
```

(revisar) visma variable que situacion_mes_actual??

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### n_meses_seg_bcra

> cantidad de meses en los que el cuit tenía al menos una deuda informada en el sistema financiero, entre Dic-2018 y Jun-2019.

Se observa que el 78% de los CUITs vienen siendo informado todos los meses (Dic-2018 a Jun-2019). Es decir, una vez que entra al sistema es dificil que salga o por lo menos en el periodo que estamos evaluando. Se observa una situación "rara" en los meses dos y tres ya que en todos los meses la tendencia es creciente, acá decrece la cantidad. Dividimos las cantidades por situación actual para ver si se observa algo y notamos que en el mes 3 donde tenemos un descenso, tenemos un pico en la proporción de situaciones dos.


```{r}
g <- df_bcra_individuals %>% 
  group_by(n_meses_seg_bcra) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=n_meses_seg_bcra
             , text = paste("Cantidad de meses: ", n_meses_seg_bcra
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Cantidad de Meses") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Cantidad de meses informados")

ggplotly(g, tooltip="text")
```


```{r warning=FALSE, message=FALSE}
g<- df_bcra_individuals %>% 
  group_by(n_meses_seg_bcra, situacion_mes_actual) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  ggplot(aes(y=PorcTotal
             , x=n_meses_seg_bcra
             , fill = situacion_mes_actual
             , text = paste("Cantidad Deudas Actual: ", n_meses_seg_bcra
                            ,"\nSituación Mes Actual: ", situacion_mes_actual
                            , "\nFrecuencia Relativa: ", PorcTotal_lbl
                            , "\nFrecuencia: ", Cantidad
             ) 
  )
  ) + 
  geom_bar(position="stack", stat="identity") +
  scale_fill_discrete("Situación") +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Cantidad de Meses") +
  ylab("Porcentaje") +
  ggtitle("Cantidad de meses informados por Situación actual") +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5)

ggplotly(g, tooltip="text")
```


Evidencia de outliers: ***No se observan outliers***

Tipo de variable: ***Cualitativa - Ordinal***

### media_deuda_total

> Promedio de la deuda total entre Dic-2018 y Jun-2019.

```{r}
data <- df_bcra_individuals
df_summary <-  summary(data$media_deuda_total)
df_t <- data.table::transpose(data.frame(unclass(df_summary)))
colnames(df_t) <- rownames(data.frame(unclass(df_summary)))
df_t <- cbind(df_t,"Desviación Standar"=sd(df_bcra_individuals$media_deuda_total))
kable(df_t, caption="Resumen de Indicadores:") %>% 
  kable_styling(bootstrap_options=Form.Basic)
```

Se observa que la media de la media de la deuda total entre Dic-2018 y Jun-2019 es de 30.92 millones. Siendo el valor minimo 1 millón y el maximo 196.85 millones (posible outlier). La mediana es 22.42 millones, la distribución es asimétrica con cola a la derecha.
 El primer cuartil (Q1) es 10.42 millones, es decir, 25% de las observaciones tiene la media de la deuda total entre Dic-2018 y Jun-2019 en 10.42 millones o menos. El tercer cuartil (Q3) es 44.42 millones, es decir, 75% de las observaciones tiene la media de la deuda total entre Dic-2018 y Jun-2019 en 44.42 millones o menos.

```{r}
g<- df_bcra_individuals %>%
  ggplot( aes(x=media_deuda_total)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Media Deuda Total") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      ggplot(aes(x=factor(0), y=media_deuda_total)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Media Deuda Total") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2

```

Para analizar posibles outliers nos guiamos por los rangos que nos brinda el boxplot por defaul, donde marca como posibles outliers los valores que esten por fuera del rango (Q1 - 1.5 * IQR; Q3 + 1.5 * IQR). En este caso encontramos valores por fuera de este rango, mas adelante analizaremos si excluimos el valor o no.


Evidencia de outliers: ***Posible outliers***

Tipo de variable: ***Cuantitativa - Continua***

### media_deuda_situacion_1

> Promedio de la deuda en situación 1 entre Dic-2018 y Jun-2019.

Teniendo en cuenta que la mayoria de los cuit del dataset están en situación uno, esta variable se comporta como la media de la deuda de todo el dataset.


```{r}
g<- df_bcra_individuals %>%
  ggplot( aes(x=media_deuda_situacion_1)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Media Deuda En Situación 1") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      ggplot(aes(x=factor(0), y=media_deuda_situacion_1)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Media Deuda En Situación 1") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2

```

Se observa un posible outliers en el boxplot, pero no los vamos a considerar como tal.

Evidencia de outliers: ***Posible outliers***

Tipo de variable: ***Cuantitativa - Continua***

### media_deuda_situacion_2

> Promedio de la deuda en situación 2 entre Dic-2018 y Jun-2019.

Analizamos esta variable únicamente con valores mayores a cero.
Para los cuits que están en situación 2, la media de la deuda es mas chica que la situación 1 con una dispersion de los datos mas chica.

```{r}
g<- df_bcra_individuals %>%
  filter(media_deuda_situacion_2>0) %>% 
  ggplot( aes(x=media_deuda_situacion_2)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Media Deuda En Situación 2") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      filter(media_deuda_situacion_2>0) %>% 
      ggplot(aes(x=factor(0), y=media_deuda_situacion_2)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Media Deuda En Situación 2") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2
```

Evidencia de outliers: ***Posible outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### media_deuda_con_garantia

> Promedio de la deuda garantizada entre Dic-2018 y Jun-2019.

Analizamos esta variable únicamente con valores mayores a cero.


```{r}
g<- df_bcra_individuals %>%
  filter(media_deuda_con_garantia>0) %>% 
  ggplot( aes(x=media_deuda_con_garantia)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Media Deuda Con Garantia") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      filter(media_deuda_con_garantia>0) %>% 
      ggplot(aes(x=factor(0), y=media_deuda_con_garantia)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Media Deuda Con Garantia") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2
```

Evidencia de outliers: ***Posibles outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### media_deuda_sin_garantia

> Promedio de la deuda no garantizada entre Dic-2018 y Jun-2019.

Analizamos esta variable únicamente con valores mayores a cero.

```{r}
g<- df_bcra_individuals %>%
  filter(media_deuda_sin_garantia>0) %>% 
  ggplot( aes(x=media_deuda_sin_garantia)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Media Deuda Sin Garantia") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      filter(media_deuda_sin_garantia>0) %>% 
      ggplot(aes(x=factor(0), y=media_deuda_sin_garantia)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Media Deuda Sin Garantia") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2
```

Evidencia de outliers: ***Posibles outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### media_deuda_en_default

> Promedio de la deuda en defaut (situación 3 o peor) entre Dic-2018 y Jun-2019.

Analizamos esta variable únicamente con valores mayores a cero.

```{r}

g<- df_bcra_individuals %>%
  filter(media_deuda_en_default>0) %>% 
  ggplot( aes(x=media_deuda_en_default)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8) +
  theme_ipsum() +
  xlab("Media Deuda En Default") +
  ylab("Densidad") +
  ggtitle("Diagrama de densidad")+
  theme(
    legend.position="none",
    plot.title = element_text(size=11)
  )
g2 <- df_bcra_individuals %>% 
      filter(media_deuda_en_default>0) %>% 
      ggplot(aes(x=factor(0), y=media_deuda_en_default)) +
      geom_boxplot(fill='#69b3a2') +
      scale_fill_viridis(discrete = TRUE, alpha=0.6, option="A") +
      theme_ipsum() +
      ggtitle("Boxplot") + 
      ylab("Media Deuda En Default") +
      xlab("") + 
      theme(
        legend.position="none",
        plot.title = element_text(size=11)
      ) 

#Imprimo los graficos juntos
g + g2
```

Evidencia de outliers: ***Posibles outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### max_situacion_mes

> Maxima situación entre Dic-2018 y Jun-2019

```{r}
g <- df_bcra_individuals %>% 
  group_by(max_situacion_mes) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=max_situacion_mes
             , text = paste("Max Situación Mes: ", max_situacion_mes
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Max Situación Mes") +
  ylab("Frecuencia Relativa") +
  ggtitle("Max Situación Mes")

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### max_sit_mes_con_garantia

> Maxima situación en las deudas garantizadas entre Dic-2018 y Jun-2019.

```{r}
g <- df_bcra_individuals %>% 
  filter(!is.na(max_sit_mes_con_garantia)) %>% 
  group_by(max_sit_mes_con_garantia) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=max_sit_mes_con_garantia
             , text = paste("Max Situación Mes Con Garantia: ", max_sit_mes_con_garantia
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Max Situación Mes Con Garantia") +
  ylab("Frecuencia Relativa") +
  ggtitle("Max Situación Mes Con Garantia")

ggplotly(g, tooltip="text")
```


Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### max_sit_mes_sin_garantia

> Maxima situación en las deudas no garantizadas entre Dic-2018 y Jun-2019.

```{r}
g <- df_bcra_individuals %>% 
  filter(!is.na(max_sit_mes_sin_garantia)) %>% 
  group_by(max_sit_mes_sin_garantia) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=max_sit_mes_sin_garantia
             , text = paste("Max Situación Mes Sin Garantia: ", max_sit_mes_sin_garantia
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Max Situación Mes Sin Garantia") +
  ylab("Frecuencia Relativa") +
  ggtitle("Max Situación Mes Sin Garantia")

ggplotly(g, tooltip="text")

```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### media_prop_situacion_1

> Promedio de la proporción de deuda en situación 1 entre Dic-2018 y Jun-2019.


```{r warning=FALSE}
g<- df_bcra_individuals %>%
  filter(media_prop_situacion_1<1) %>% 
  ggplot( aes(x=media_prop_situacion_1)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### media_prop_situacion_2

> Promedio de la proporción de deuda en situación 2 entre Dic-2018 y Jun-2019.

```{r warning=FALSE}
g<- df_bcra_individuals %>%
  filter(media_prop_situacion_2>0) %>% 
  ggplot( aes(x=media_prop_situacion_2)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### media_prop_default

> Promedio de la proporción de deuda en default entre Dic-2018 y Jun-2019.

Para analizar esta variable nos vamos a quedar únicamente con los casos que tuvieron alguna vez deuda garantizada entre Dic-2018 y Jun-2019.

```{r warning=FALSE}
g<- df_bcra_individuals %>%
  filter(media_prop_default > 0) %>% 
  ggplot( aes(x=media_prop_default)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### media_prop_con_garantia

> Promedio de la proporción de deuda garantizada entre Dic-2018 y Jun-2019.

Para analizar esta variable nos vamos a quedar únicamente con los casos que tuvieron alguna vez deuda garantizada entre Dic-2018 y Jun-2019.

```{r warning=FALSE}
g<- df_bcra_individuals %>%
  filter(media_prop_con_garantia > 0) %>% 
  ggplot( aes(x=media_prop_con_garantia)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### prop_tuvo_garantia

> Proporción de meses en los cuales el cuit tuvo deuda garantizada, entre Dic-2018 y Jun-2019.

Para analizar esta variable nos vamos a quedar únicamente con los casos que tuvieron alguna vez en deuda garantizada entre Dic-2018 y Jun-2019.

```{r warning=FALSE}
g<- df_bcra_individuals %>%
  filter(prop_tuvo_garantia > 0) %>% 
  ggplot( aes(x=prop_tuvo_garantia)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### prop_mora_30_dias_seg

> Proporción de meses en los cuales el cuit estuvo en situación 2, entre Dic-2018 y Jun-2019.

Para analizar esta variable nos vamos a quedar únicamente con los casos que tuvieron alguna vez en situación 2.

```{r warning=FALSE}
g<- df_bcra_individuals %>%
  filter(prop_mora_30_dias_seg > 0) %>% 
  ggplot( aes(x=prop_mora_30_dias_seg)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### prop_default_seg

> Proporción de meses en los cuales el cuit estuvo en default, entre Dic-2018 y Jun-2019.

Para analizar esta variable nos vamos a quedar únicamente con los casos que tuvieron alguna vez en default.

```{r message=FALSE, warning=FALSE}
g<- df_bcra_individuals %>%
  filter(prop_default_seg > 0) %>% 
  ggplot( aes(x=prop_default_seg)) +
  geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### peor_situacion_respuesta

> Situación crediticia más grave en todas las deudas del cuit entre Jul-2019 y Jun- 2020.

```{r}
g <- df_bcra_individuals %>% 
  group_by(peor_situacion_respuesta) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=peor_situacion_respuesta
             , text = paste("Peor Situación Respuesta: ", peor_situacion_respuesta
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  xlab("Situación crediticia") +
  ylab("Frecuencia Relativa") +
  ggtitle("Peor Situación de Respuesta")

ggplotly(g, tooltip="text")
```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cualitativa - Ordinal***

### default

> Situación crediticia más grave mayor o igual 3 en todas las deudas del cuit entre Jul-2019 y Jun-2020.

De los 18021 cuit existentes en el dataset 16449 (91%)  mantienen su situación entre Jul-2019 y Jun-2020. Mientras que el 9% (1572 cuits) agravan su situación crediticia entre Jul-2019 y Jun-2020.

```{r}
g <- df_bcra_individuals %>% 
  group_by(default) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=default
             , text = paste("Situación: ", default
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Situación") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Situación post Jun-2019")

ggplotly(g, tooltip="text")

```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### mora_mayor_30_dias

> Situación crediticia más grave igual 2 en todas las deudas del cuit entre Jul-2019 y Jun-2020.

De los 18021 cuit existentes en el dataset 15155 (84%) su situación crediticia más grave igual 2 en todas las deudas del cuit entre Jul-2019 y Jun-2020 no cambia. Mientras que el 16% (2866 cuits) cambia.

```{r}
g <- df_bcra_individuals %>% 
  group_by(mora_mayor_30_dias) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
         PorcTotal = (Cantidad / sum(Cantidad))*100
  ) %>% 
  arrange(desc(Cantidad)) %>% 
  ggplot(aes(y=PorcTotal
             , x=mora_mayor_30_dias
             , text = paste("Mora Mayor 30 Dias: ", mora_mayor_30_dias
                            , "\nPorcentaje del Total: ", PorcTotal_lbl
                            , "\nCantidad: ", Cantidad) 
  )) + 
  geom_bar(position="stack", stat="identity", fill='#69b3a2') +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Situación") +
  ylab("Frecuencia Relativa") +
  ggtitle("Frecuencia Relativa - Mora Mayor 30 Dias")

ggplotly(g, tooltip="text")

```

Evidencia de outliers: ***No se observan outliers ***

Tipo de variable: ***Cuantitativa - Continua***

### Con clusiones generales con los outliers

**Si bien en muchas variables observo que existe varios outliers en realidad son posibles outliers definidos por el criterio del boxplot. Pero para el modelo que venimos trabajando son valores posibles.**

## b. Matriz de correlacion

> Calcule e interprete la matriz de correlaciones de variables disponibles a Jun-2019 (las posibles predictores de default en el período Jul-2019 a Jun-2020).

Para realizar la matriz de correlacion vamos a descartar las siguientes variables

* Identificador
  + id_individuo

* Variables categóricas
  + situacion_mes_actual
  + tiene_garantia_actual
  + mora_30_dias_mes_actual
  + max_situacion_mes
  + max_sit_mes_con_garantia
  + max_sit_mes_sin_garantia
  + tipo_persona
  + default


* Variables que hacen referencia a un período posterior
  + peor_situacion_respuesta
  + mora_mayor_30_dias

Luego realizó la matriz de correlación

```{r message=FALSE}

variables <- c(
  "n_deudas_actual", "proxy_edad_actual", "deuda_total_actual", "deuda_con_garantia_actual"
  , "prop_con_garantia_actual", "n_meses_seg_bcra", "media_deuda_total", "media_deuda_situacion_1", "media_deuda_situacion_2", "media_deuda_con_garantia", "media_deuda_sin_garantia", "media_deuda_en_default", "media_prop_situacion_1", "media_prop_situacion_2", "media_prop_default", "media_prop_con_garantia", "prop_tuvo_garantia", "prop_mora_30_dias_seg", "prop_default_seg"
  )

df_analisis <- df_bcra_individuals[, variables]
mat_cor <- as.data.frame(cor(x = df_analisis, method = "pearson"))

M <- cor(x = df_analisis, method = "pearson")
corrplot(M, tl.col = "black")
```

**Conclusiones: **

* Se evidencian correlaciones positivas altas entre las variables:
  + deuda_total_actual con:
    - media_deuda_total
    - media_deuda_situacion_1
    - media_deuda_sin_garantia
  + deuda_con_garantia_actual con:
    - prop_con_garantia_actual
    - media_deuda_con_garantia
    - media_prop_con_garantia
    - prop_tuvo_garantia
  + prop_con_garantia_actual con:
    - media_deuda_con_garantia
    - media_prop_con_garantia
    - prop_tuvo_garantia
  + media_deuda_total con:
    - media_deuda_situacion_1
    - deuda_total_actual
    - media_deuda_sin_garantia
  + media_deuda_situacion_1 con:
    - media_deuda_sin_garantia
  + media_deuda_con_garantia con:
    - media_prop_con_garantia
    - prop_tuvo_garantia
  + media_prop_con_garantia con:
    - media_prop_con_garantia
  + prop_mora_30_dias_seg con:
    - prop_default_seg
    
* Se evidencian correlaciones negativa altas entre las variables:
  + media_prop_situacion_1 con:
    - media_prop_situacion_2
    - media_prop_default
    - prop_mora_30_dias_seg
    - prop_default_seg
  
* Como marcamos en las relaciones, hay una variable (**media_prop_situacion_1**) que tiene una corelación negativa con otras cuatro variables. En cambio otras que tienen una corelación fuerte positiva, dentro de las cuales se resaltan **deuda_con_garantia_actual, deuda_total_actual, prop_con_garantia_actual, prop_tuvo_garantia, media_deuda_sin_garantia** las cuales se relacionan con otras tres variables.


## c. Análisis de Componentes Principales

> Realice un análisis de componentes principales sobre las mismas variables. ¿Qué porcentaje de la variabilidad total logran explicar las dos primeras componentes? ¿Es posible realizar una interpretación sobre los componentes? ¿Cuál? ¿Logran esas componentes diferenciar a los cuits según el tipo de persona?

> Al tener una variabilidad amplia de valores en las medidas vamos a tener que normalizar las variables para que esa variabilidad disminuya. Vamos a trabajar con la matriz R.

```{r}
#vuelvo a definir vector "variables" pero es igual que el de arriba.
variables <- c(
  "n_deudas_actual", "proxy_edad_actual", "deuda_total_actual", "deuda_con_garantia_actual"
  , "prop_con_garantia_actual", "n_meses_seg_bcra", "media_deuda_total", "media_deuda_situacion_1", "media_deuda_situacion_2", "media_deuda_con_garantia", "media_deuda_sin_garantia", "media_deuda_en_default", "media_prop_situacion_1", "media_prop_situacion_2", "media_prop_default", "media_prop_con_garantia", "prop_tuvo_garantia", "prop_mora_30_dias_seg", "prop_default_seg")

#Selecciono variables
df_analisis <- df_bcra_individuals[, variables]
#Realizo PCA
bcraPca <- prcomp(as.matrix(df_analisis),center = T, scale. = T)
```


### ¿Qué porcentaje de la variabilidad total logran explicar las dos primeras componentes?

```{r}
summary(bcraPca)
```

La fila Proportion of Variance indica la variabilidad que explica cada componente. Por ejemplo la componente PC1 contempla un 25.64% de variabilidad. Si vemos la fila Cumulative Proportion tenemos la variabilidad acumulada. Por ejemplo si contemplamos las dos primeras componentes (PC1 y PC2) tenemos un 47.83% de variabilidad acumulada. La fila Standard deviation nos da la desviacion standar de cada componente, si hacemos el cuadrado de esta fila optenemos los valores propios (o eig values)

Gráfica:

```{r}
fviz_eig(bcraPca, addlabels = TRUE)
```

EIG values:

```{r}
bcraPca$sdev^2
```

Si nos guiamos por el criterio de Kaiser (utilizar los componentes proncipales con eig values mayores a 1) deberíamos tomar los 5 primeros componentes. Los cuales explican el 81.23% de la variabiliad.


### ¿Es posible realizar una interpretación sobre los componentes? ¿Cuál? 

Para interpretar las componentes podemos observar la matriz de carga:

```{r}
#knitr::kable(as.data.frame(unclass(bcraPca$rotation)))
tmp <- as.data.frame(unclass(bcraPca$rotation))

#Muevo el indice de fila a columna
tmp <- cbind(Variables = rownames(tmp), tmp)

tmp %>%
  DT::datatable(
    selection = 'none', rownames = '', filter = 'none',
    extensions = "FixedColumns",
    options = list(
      paging = TRUE, searching = TRUE, info = FALSE,
      sort = TRUE, scrollX = TRUE, scrollY = "100%", fixedColumns = list(leftColumns = 2)
    )
  )
```


Si observamos la columna PC1, vemos como influye cada variable (cada fila) en la componente 1. Para la componente uno todas las variables influyen en forma positiva salvo **media_prop_situacion_1**. También observamos que hay un grupo de variables que tiene entre un 37% y 36% de variabilidad **(media_deuda_con_garantia, media_prop_con_garantia, prop_tuvo_garantia, prop_con_garantia_actual, deuda_con_garantia_actual)** estas son las que mayor variabilidad poseen, esto quiere decir que estas variables influyen en una proporción parecida. Luego hay otro grupo que va de 18% al 29% de variabilidad **(media_deuda_total, media_deuda_situacion_1, deuda_total_actual, media_deuda_sin_garantia)**. Es dicir, para la componente uno no tenemos una "buena" representación de las variables, es mas, se tienen varios grupos lo cual no es bueno. 

Para la componenete 2 (Columna PC2) vemos que las variables que antes tenian una representacion baja, ahora tienen una alta representación. Por ejemplo, las variables **prop_mora_30_dias_seg, media_prop_default, prop_default_seg, media_deuda_en_default, media_prop_situacion_2, media_deuda_situacion_2** tenian una representación inferior al 10% ahora tienen una representación entre el 44% y 26%.


### ¿Logran esas componentes diferenciar a los cuits según el tipo de persona?

Para responder esto podemos hacer una gráfica entre PC1 y PC2 y ver si rapidamente podemos encontrar una division de los puntos por la variable **tipo_persona**. 

```{r}
#Agrego la variable tipo_persona al data frame que realice el PCA.
df_analisis$tipo_persona <- df_bcra_individuals[, 'tipo_persona']

autoplot(bcraPca, 
         data = df_analisis, 
         colour = 'tipo_persona', 
         loadings = FALSE, 
         loadings.label = FALSE, 
         loadings.label.size = 3)

```

En la gráfica no se distingue una division de los puntos teniendo en cuenta la variable **tipo_persona**. Podriamos intentar graficar una componente mas y ver si en un grafico 3D se llegue a distinguir una division u otra alternativa podria ser realizar un clustering de las cinco componente principales y ver si esos cluster tienen alguna particularidad segun la variable tipo_persona. 

## d. Subgrupos de cuits

> ¿Existen distintos subgrupos de cuits en los datos? ¿Cuántos logra identificar? ¿Qué características tienen? Explique la metodología utilizada.

Para este punto voy hacer un análisis de cluster con un metodo no jerarquico.

### ¿Existen distintos subgrupos de cuits en los datos? 

Para el análisis vamos a utilizar las variables numéricas. Selecciono las variables numéricas y estandarizo.

```{r}
#vuelvo a definir vector "variables" pero es igual que el de arriba. (en este caso cambio el nombre para que sea mas representatitvo a variablesNumericas)
variablesNumericas <- c(
               "n_deudas_actual", "proxy_edad_actual", "deuda_total_actual"
               , "deuda_con_garantia_actual", "prop_con_garantia_actual"
               , "n_meses_seg_bcra"
               , "media_deuda_total", "media_deuda_situacion_1", "media_deuda_situacion_2"
               , "media_deuda_con_garantia", "media_deuda_sin_garantia", "media_deuda_en_default"
               , "media_prop_situacion_1", "media_prop_situacion_2", "media_prop_default"
               , "media_prop_con_garantia", "prop_tuvo_garantia", "prop_mora_30_dias_seg"
               , "prop_default_seg"
)

#Selecciono variables
df_analisis <- df_bcra_individuals[, variablesNumericas]

#Normalizo las variables
df_bcra_individuals_std <- scale(df_analisis)

```


### ¿Cuántos logra identificar? 

Para ver cuantos cluster hay nos vamos a guiar por el metodo de **Suma de Cuadrados** y por el **Indice Silhouette**

**Suma de Cuadrados**

```{r warning=FALSE}
#Suma de cuadrados
wss <- (nrow(df_bcra_individuals_std) - 1) * sum(apply(df_bcra_individuals_std, 2, var))
for (i in 2:10) {
  wss[i] <- sum(kmeans(df_bcra_individuals_std, centers = i)$withinss)
}
plot(1:10, wss, type = "b", xlab = "Number of Clusters",
     ylab = "Suma de cuadrados dentro de los clusters")
```

**Observación:** Utilizamos la suma de cuadrados para ver la cantidad de centros (Clusters) a elegir. El valor a seleccionar es el clusters donde la curva deja de decreecer abrutamente. Consideramos que el “codo” se encuentra en los los clusters 4 o 6. Antes de seleccionar un numero de clusters vamos a realizar un análisis similar con el Indice Silhouette

**Indice Silhouette**

```{r}
#Indice Silhouette
fviz_nbclust(df_bcra_individuals_std, kmeans, method = "silhouette") +
  labs(title    = "Número óptimo de clusters a considerar",
       subtitle = "Indice Silhouette")
```

**Observación:** Para seleccionar el clusters debemos buscar los cambios de tendencia dentro de la gráfica (Máximos). Como primer alternativa aparece 2, pero lo vamos a descartar debido a que pueden ser una agrupacion "mayor". La cual no nos permita ver subgrupos dentro de esos dos grupos. En el gráfico realizado los posibles valores serian 4 y 6 (ya que están los dos a la misma altura).

**Seleccionamos 6 clusters**

### ¿Qué características tienen? Explique la metodología utilizada.

**Gereración del modelo**

```{r}
# Agrupamiento no jerarquico
clustering <- kmeans(df_bcra_individuals_std, centers = 6)

df_analisis$cluster     <- clustering$cluster
df_bcra_individuals_std         <- data.frame(df_bcra_individuals_std)
df_bcra_individuals_std$cluster <- clustering$cluster
```

**Analisis**


```{r message=FALSE}
df_analisis2 <- cbind(df_analisis, select(df_bcra_individuals, default))
df_analisis2$default <- as.factor(df_analisis2$default)

g <- df_analisis2 %>% 
  group_by(cluster) %>% 
  summarise(Cantidad = n()) %>% 
  mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
           PorcTotal = (Cantidad / sum(Cantidad))*100
        )  %>% 
  ggplot(aes(y=PorcTotal
             , x=cluster
             , text = paste("Cluster: ", cluster
                            , "\nFrecuencia Relativa: ", PorcTotal_lbl
                            , "\nFrecuencia: ", Cantidad
                      ) 
             )
         ) + 
    geom_bar(position="stack", stat="identity", fill='#69b3a2') +
    geom_text(aes(label = PorcTotal_lbl), vjust = 1.5) +
    theme_ipsum() +
    theme(plot.title = element_text(size=11)) +
    xlab("Clusters") +
    ylab("Frecuencia Relativa") +
    ggtitle("Frecuencia Relativa - Cantidad por cluster")

ggplotly(g, tooltip="text")

```

Comportamiento de variable default por cada cluster:

```{r message=FALSE}

g <-df_analisis2 %>% 
    group_by(cluster,default) %>% 
    summarise(Cantidad = n()) %>% 
    mutate(PorcTotal_lbl = scales::label_percent( suffix = " %")(Cantidad / sum(Cantidad)),
           PorcTotal = (Cantidad / sum(Cantidad))*100
    ) %>% 
    arrange(cluster,default) %>% 
    ggplot(aes(y=PorcTotal
           , x=cluster
           , fill = default
           , text = paste("Cluster: ", cluster
                          ,"\nDefault: ", default
                          , "\nFrecuencia Relativa: ", PorcTotal_lbl
                          , "\nFrecuencia: ", Cantidad
                          ) 
              )
          ) + 
  geom_bar(position="stack", stat="identity") +
  theme_ipsum() +
  theme(plot.title = element_text(size=11)) +
  xlab("Clusters") +
  ylab("Porcentaje") +
  geom_text(aes(label = PorcTotal_lbl), vjust = 1.5)

ggplotly(g, tooltip="text")

```

**Conclusión:** Los cluster 2 y 3 son los mas pequeños y a su vez si los cuits caen en esos cluster tienen una alta probabilidad de empeorar su situación crediticia entre Jul-2019 y Jun-2020, variable default=1.

Al momento de realizar los clusters me parecio interesante mirar la composicion de cada uno teniendo en cuenta principalmente la variable **default** que si bien no se utilizo para hacer el cluster, luego la agregue para ver como quedaban los clusters en función a esta variables.
Analizando el grafico observamos que en los cluster 2 y 3 están los cuits que empeoraron la situación crediticia entre Jul-2019 y Jun-2020. Entonces si miramos el resto de las variables teniendo en cuenta esto, podriamos responder algunas de las siguientes preguntas:

* La cantidad de entidades en las cuales los cuits tenian deuda podria estar asociada al agravamiento de la situación crediticia? 
* Las edades puede influir en el agravamiento de la situación crediticia? 
* La deuda total actual nos dice algo respecto al agravamiento de la situación crediticia? Es decir, los cuits que mayor deuda total actual tienen cayeron en situación 3 o mas alta?
* etc..

Debajo realizo dicho análisis.

```{r}
generarBoxPlotsPorGrupos <- function(
    df, var_interes, grupos = "cluster", a = 0, vj = 0
) {
  
  # Convertir a cuadro de datos
  df <- data.frame(df)
  
  # Definir etiquetas que con la cantidad de observaciones por grupos
  etiquetas <- paste(
    levels(factor(df[, grupos])), "\n(N = ", table(df[, grupos]), ")", sep = ""
  )
  
  # Generar gráfico
  boxplot <- ggplot(
    df, 
    aes(x = factor(get(grupos)), y = get(var_interes), 
        fill = factor(get(grupos)))) + 
    geom_boxplot() +
    theme(legend.position = "none") +
    scale_x_discrete(name = paste0(grupos), labels = etiquetas) +
    scale_y_continuous(name = paste0(var_interes))  + 
    geom_hline(yintercept = median(df[, var_interes])) +
    theme(axis.text.x  = element_text(size = rel(0.75), angle = a, vjust = vj )) 
  
  return(boxplot)
}


# Generar los boxplot para cada variable
for (j in 1:length(variablesNumericas)){
  nombregrafico <- paste0("b", j)
  assign(
    nombregrafico, 
    generarBoxPlotsPorGrupos(
      df = df_analisis,
      var_interes = variablesNumericas[j]
    )
  )
}

plot_grid(b1, b2, b3, b4, ncol = 2)
```

```{r}
plot_grid(b5, b6, b7, b8, ncol = 2)
```

```{r}
plot_grid(b9, b10, b11, b12, ncol = 2)
```

```{r}
plot_grid(b13, b14, b15, b16, ncol = 2)
```

```{r}
plot_grid(b17, b18, b19, ncol = 2)
rm(b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19)
```



**Conclusión: **(por cuestiones de tiempo voy a omitir variables que no considere relevante)

* Los cluster están bien definidos?
  + Los cluster 1 y 4 podrian agruparse, la unica variable que cambia es **proxy_edad_actual** donde es un poco mas elevado el promedio apra el cluster 4, es decir, la unica diferencia encontrada es que el cluster 4 tienen cuits mas jovenes.
  + Los cluster 2 y 3 esta bien que esten divididos, notamos diferencias en varias variables, como ser: **n_meses_seg_bcra, media_deuda_situacion_2, media_deuda_en_default, media_prop_situacion_2, media_prop_default, prop_mora_30_dias_seg, prop_default_seg **
  + El cluster 5 tiene un corportamiento distinto en varias variables, no se puede asociar a ningún otro cluster.
  + El cluster 6 es tentador agruparlo con 1 y 4. La unica variable que difiere es **n_meses_seg_bcra**  

* n_deudas_actual: Los clusters 1 a 4 tienen una distribución parecida de la variable n_deudas_actual. El cluster 5 posee una dispersion mayor de los datos y una media mas elevada (aprox 2). El cluster 6 la media de los cuit tiene 1 deuda con una sola entidad y tiene una menor dispersion de los datos con respecto a los otros clusters. **Si miramos la variable Cantidad de Deuda en entidades por cada cuit, no podemos decir decir si el cuit va a caer o no en situación 3 o peor para el peridodo Jul-2019 a Jun-2020**

* proxy_edad_actual: Para esta variable primero vamos a ver la dispersion de los datos, para los clusters 1 y 4 es menor que para el resto de los clusters. Luego en cuento al rango el cluster 1 es el que tendria los números de documentos mas chicos, por ende tendria a los cuits con mayor edad, luego para el resto de los clusters, las medias de los nro de documentos es pareja, por ende podemos decir que el rango de edades es parejo en el resto de los clusters.

* deuda_total_actual: Los clusters de 1 a 4 poseen medias parecidas, para los cluster 1 y 4 la dispersion de los datos es menor que para los clusters 2 y 3. Los cuits perteneciente al cluster 5 son los que mayor deuda total actual tienen. Mientras que el cluster 6 es el que menor media de deuda_total_actual posee.

*Se podria seguir describiendo mucho mas pero por cuestiones de tiempo llegué hasta acá.*

## e. Modelo predictivo

> Construya un modelo predictivo para a variable respuesta ‘default’ utilizando sólo las variables disponibles a Jun-2019. ¿Qué capacidad predictiva tiene ese modelo?


### Creacion del modelo

Para realizar la predicción voy a utilizar las variables disponibles a Jun-2019 como pide el enunciado hay una situación particular con las variables **max_sit_mes_con_garantia** y **max_sit_mes_sin_garantia** considero que tienen informacion redundante con la variable **max_situacion_mes**. Es por esto que no las tengo en cuenta.

```{r}
#Ponemos una semilla
set.seed(12345)

##Convierto a factor
df_bcra_individuals$default <- as.factor(df_bcra_individuals$default)
df_bcra_individuals$tipo_persona <- as.factor(df_bcra_individuals$tipo_persona)

##Columnas que voy a utilizar
columns <- c("tipo_persona", "n_deudas_actual", "proxy_edad_actual"
             , "deuda_total_actual", "deuda_con_garantia_actual"
             , "situacion_mes_actual", "prop_con_garantia_actual"
             , "tiene_garantia_actual", "mora_30_dias_mes_actual"
             , "n_meses_seg_bcra", "media_deuda_total"
             , "media_deuda_situacion_1", "media_deuda_situacion_2"
             , "media_deuda_con_garantia", "media_deuda_sin_garantia"
             , "media_deuda_en_default", "max_situacion_mes"
             , "media_prop_situacion_1", "media_prop_situacion_2"
             , "media_prop_default", "media_prop_con_garantia"
             , "prop_tuvo_garantia", "prop_mora_30_dias_seg"
             , "prop_default_seg"
             , "default" )

#Dividimos en train y test
percent_train <- 0.8

partition <- createDataPartition(y = df_bcra_individuals$default, p = percent_train, list = FALSE)

df_test <- df_bcra_individuals[-partition, columns]
df_train <- df_bcra_individuals[partition, columns]

#Borro variable que no voy a volver a utilizar
rm(partition) 

#Creacion del arbol (grid search + cross validation) grid search con CP.
#validar que repeatedcv sea CV.
caret.control <- trainControl(method = "repeatedcv",
                              number = 15, #15kf
                              repeats = 7) #repetidas 7 veces
arbolcv <- train(default ~ ., 
                 data = df_train,
                 method = "rpart",
                 trControl = caret.control,
                 tuneLength = 15) #se usan 15 valores distíntos para de CP
arbolcv
```

**Gráfica de Resultados**

```{r}
plot(arbolcv)
```

Conclusiones: Mirando el grafico de arriba Complejidad de Parametros vs Accuracy vemos que el CP=0.003554502 es el que mejor Accuracy tiene. Es decir, el que meyor cantidad de observacion correctas sobre el total de observaciones tiene (def. Accuracy). Dando un Accuraci de 92.03%.
Esta exactitud es en los datos de train. Mas adelante avaluaremos el modelo para los datos de trest.

### Importancia de las variables

Para el mejor modelo las variables influyen en el siguiente orden:

```{r}

var.imp <- varImp(arbolcv)
plot(var.imp)

```

La principal variable es la proporción de meses en los cuales el cuit estuvo en situación 2, entre Dic-2018 y Jun-2019 (prop_mora_30_dias_seg). Luego el algoritmo mira si el cuit estaba en situación 2 en Jun-2019 (mora_30_dias_mes_actual) y como tercera variable esta la situación crediticia más grave en todas las deudas del cuit en Jun-2019. (situacion_mes_actual)

### Evaluación del modelo

Es importante remarcar que estamos ante un conjunto de datos desbalanceado, es decir, nosotros tenemos que predecir si la situación crediticia más grave mayor o igual 3 en todas las deudas del cuit entre Jul-2019 y Jun-2020. Y los casos que caen en esta situación son pocos con respecto a los que se mantienen.

**Matriz de confusión y Accuracy**

Para la matriz de confusión tenemos:

* VN: 3241 Verdaderos Negativos, es decir, son cuits que se predijeron sin cambio de situación y realmente no habian cambiado de situación. 

* VP: 92 Verdaderos Positivos, son cuits que se predijeron con un cambio de situación y realmente habian cambiado de situación.  

* FN: 61 Falsos Negativos, son cuit que se predijeron como cambio de situación cuando en realidad no cambiaron de situación.

* FP: 214 Falso Positivos, son cuit que se predijeron como que no cambian de situación cuando en realidad cambiaron de situación.

Por otro lado si observamos el Accuracy en los datos de Test vemos que es 92.37%. Mejor que en los datos de entrenamiento.


```{r}
predi = as.vector(predict(arbolcv,newdata = select(df_test, -default) )) %>% as.integer()
confusionMatrix(table(predi, df_test$default))
```


**Curva ROC**

Este indicador aporta a establecer que tan bueno es el modelo prediciendo las clases, en este caso 0 o 1. Si el area bajo la curba (AUC) es 1 significa que el clasificador puede distinguir correctamente entre todos los puntos de clase Positivos y Negativos. Sin embargo, si el AUC hubiera sido 0, entonces el clasificador predeciría todos los negativos como positivos y todos los positivos como negativos.

Cuando el area de la curba esta entre  [0.5 y 1] existe una alta probabilidad de que el clasificador pueda distinguir los valores de clase positivos de los negativos. Esto es así porque el clasificador es capaz de detectar más números de Verdaderos positivos y Verdaderos negativos que de Falsos negativos y Falsos positivos.

```{r}

vecPred = as.vector(predict(arbolcv, newdata = select(df_test, -default)))
mdl_auc <- Metrics::auc(actual = vecPred, predicted = df_test$default)
pred <- prediction(predict(arbolcv, type = "prob", newdata = select(df_test, -default))[, 2], df_test$default)
plot(performance(pred, "tpr", "fpr"),
     main= paste0("AUC = ", round(mdl_auc, 4)))
abline(0, 1, lty = 2)
```

## f. Predicciones

> ¿Utilizaría el modelo construido para evaluar futuros solicitantes de crédito? Justifique su respuesta.

Teniendo en cuenta el análisis univariado de la variables del **Punto a**, cuando analizamos la variable **default** vimos que el 91% (16499 cuits) del data set poseia valor 0 para dicha variable y un 9% (1572 cuits) valor 1.
Sin hacer un arbol de clasificación podriamos haber dicho todo lo que venga lo ponemos como que no cambio, es decir, asignamos un cero. Con este criterio ibamos a tener un 91% de probabilidad de que sea correcto. (Una forma de decir)
Si vemos el 91% es un valor tentador es por eso que para poder responder esta pregunta voy a analizar otras metricas como ser **Precision, Recall y F1-score**

### Precision

$$
\frac{TP}{(TP+FP)}
$$

Es la proporción de observaciones que se predice que estarán en la clase positiva.


```{r}
predicted <- as.vector(predict(arbolcv, newdata = select(df_test, -default)))
actual <- as.numeric(as.character(df_test$default))

Metrics::precision(predicted, actual)
```

El 66.19 de las evaluaciones caeran en la clase positiva, es decir, 6,5 de 10 cuits nuevos van a ser marcados como que cambian de situación. Pero esos 6,5 no necesariamente van a estar bien clasificados.  

### Recall

$$ 
\frac{TP}{(TP+FN)} 
$$

Recall, también conocida como tasa de verdaderos positivos (TPR), sensitivity o tasa de aciertos, es una medida del rendimiento de un sistema de clasificación binaria. Se calcula como la proporción de predicciones positivas verdaderas (es decir, el número de veces que el modelo predijo correctamente la clase positiva) al número total de casos positivos reales. En otras palabras, el recuerdo es una medida de qué tan bien el modelo puede identificar todos los casos positivos.

```{r}
Metrics::recall(predicted, actual)
```

Un recall 60.13% considero que es bajo para un modelo. Es decir, solo va a predecir 6 de cada 10 caso que cambien de situación. 


### F1-score

$$
\frac{(2 * Precision * Recall)}{(Precision+Recall)}
$$

F1 es una medida del rendimiento de un modelo que combina precisión y recall Se define como la media armónica de precisión y recuperación, donde el mejor valor es 1 y el peor valor es 0.

Hay otra métrica llamada Precisión. En R, la precisión es una medida del rendimiento de un modelo que indica cuántas de las predicciones positivas realizadas por el modelo son realmente correctas. Se calcula como el número de predicciones positivas verdaderas dividido por el número de predicciones positivas verdaderas y positivas falsas.

```{r}
(2* Metrics::precision(predicted, actual) * Metrics::recall(predicted, actual))/(Metrics::precision(predicted, actual) + Metrics::recall(predicted, actual))
```

Como mencione anterior mente, F1-score es la cambinación entre Precision Recal siendo su rango de 0 a 1, siendo 1 la mejor evaluación, acá nos encontramos con 0,4 es decir estamos por debajo de la mitad. 

**Como conclusion, decido no tomar el modelo como adecuado para evaluar a futuros solicitantes de créditos.**




